# 分布式事务 
- 分布式事务就是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于不同的分布式系统的不同节点之上。
- 分布式事务就是为了保证不同数据库的数据一致性。

## 原因
1. 数据库分库分表
![](https://img-blog.csdn.net/20170320083203650?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
2. 应用SOA化（服务化）
![](https://img-blog.csdn.net/20170320083209525?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

## 事务的ACID特性
1. 原子性
> 在整个事务中的所有操作，要么全部完成，要么全部不做，没有中间状态。对于事务在执行中发生错误，所有的操作都会被回滚，整个事务就像从没被执行过一样。
2. 一致性
> 事务的执行必须保证系统的一致性，就拿转账为例，A有500元，B有300元，如果在一个事务里A成功转给B 50元，那么不管并发多少，不管发生什么，只要事务执行成功了，那么最后A账户一定是450元，B账户一定是350元
3. 隔离性
> 事务与事务之间不会互相影响，一个事务的中间状态不会被其他事务感知。
4. 持久性
> 所谓的持久性，就是说一单事务完成了，那么事务对数据所做的变更就完全保存在了数据库中，即使发生停电，系统宕机也是如此。

## 分布式事务的应用场景
1. 支付
> 最经典的场景就是支付了，一笔支付，是对买家账户进行扣款，同时对卖家账户进行加钱，这些操作必须在一个事务里执行，要么全部成功，要么全部失败。而对于买家账户属于买家中心，对应的是买家数据库，而卖家账户属于卖家中心，对应的是卖家数据库，对不同数据库的操作必然需要引入分布式事务。

2. 在线下单
> 买家在电商平台下单，往往会涉及到两个动作，一个是扣库存，第二个是更新订单状态，库存和订单一般属于不同的数据库，需要使用分布式事务保证数据一致性。

## 解决方案
1. 基于XA协议的两阶段提交
XA中大致分为两部分：事务管理器和本地资源管理器。其中本地资源管理器往往由数据库实现，比如Oracle、DB2这些商业数据库都实现了XA接口，而事务管理器作为全局的调度者，负责各个本地资源的提交和回滚。
![](https://img-blog.csdn.net/20170320083214850?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

2. 消息事务+最终一致性
> 消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败
![](https://img-blog.csdn.net/20170320083222287?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)
![](https://img-blog.csdn.net/20170320083228100?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvbWluZV9zb25n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

**最终一致**

## TCC编程模式
> 所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。

### 对比
> 部分控制的好处是并发量和性能很好，缺点是数据一致性减弱了，完全控制则是牺牲了性能，保障了一致性，

## 三种分布式事务解决方案

1. 异步消息确保型
> 异步消息确保型方案，基于MQ中间件实现，或者说是对MQ不支持分布式事务进行的改进，使用场景比较广，适合于对实时性要求不高的应用场景。
![](https://img-blog.csdn.net/20180523175726420?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RjbF82NjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)


1. TCC事务补偿型
> TCC事务补偿型方案，采用两阶段实现，但有别于2PC协议的两阶段提交，实时性较高，基于AOP实现，适合于实时的系统交互。
![](https://img-blog.csdn.net/20180523175759251?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3RjbF82NjY2/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

3. 最大努力通知型
> 最大努力通知型方案，适合于跨平台的业务活动，例如商户通知，允许多次通知、支持查询校对、定期对账


三种解决方案均是基于柔性事务实现最终一致性


## 异步消息确保型
1. 创建订单之前，创建预发送消息，保存到消息表中，此时消息状态为：未发送
2. 创建订单，如果创建订单失败则将消息表预发送消息删除
3. 创建订单成功后，修改消息表预发送消息状态为发送中，并发送消息至mq
4. 如果发送消息失败，则订单回滚并删除消息表消息；发送成功则万事大吉

1. 从mq消息中间件中监听并消费消息，将json消息转为订单对象
2. 根据消息编号查询该消息是否已被消费，保证幂等性
3. 如果消息未被消费（即存在此消息），则产品表扣减库存；如果已经消费（不存在此消息），则不做处理
4. 产品表扣减库存成功，则删除此消息；扣减失败，则不做处理
5. 定时任务会定时扫描消息表中超时未被消费的消息，然后尝试重发，如果超过最大重试次数后仍未被消费，则记录日志并通知工作人员进行人工补偿操作


## mysql 对 XA的支持




























